package main

import (
	"image/color"
	"sort"
	"testing"
)

func TestNewColorFromString(t *testing.T) {
	tt := []struct {
		in  string
		err error
	}{
		{in: "#010101"},
		{in: "#AABBCC"},
		{in: "#ab0194"},
		{in: "invalid", err: ErrInvalidColorString},
		{in: "9123", err: ErrInvalidColorString},
	}
	for _, tc := range tt {
		t.Run(tc.in, func(t *testing.T) {
			_, err := NewColorFromString(tc.in)
			if err == tc.err {
				return
			}
			if err == nil {
				t.Fatalf("expected error %q for input %q", tc.err, tc.in)
			}
			t.Fatalf("did not expect error %q for input %q", err, tc.in)
		})
	}
}

func TestColorRGB(t *testing.T) {
	tt := []struct {
		c       string
		r, g, b uint8
	}{
		{
			c: "#FF0000",
			r: 0xFF,
		},
		{
			c: "#00FE00",
			g: 0xFE,
		},
		{
			c: "#0000BB",
			b: 0xBB,
		},
	}
	for _, tc := range tt {
		t.Run(tc.c, func(t *testing.T) {
			c, err := NewColorFromString(tc.c)
			if err != nil {
				t.Fatalf("unexpected test error: %v", err)
			}
			if r := c.R; r != tc.r {
				t.Errorf("expected red to be %#02x, but got %#02x", tc.r, r)
			}
			if g := c.G; g != tc.g {
				t.Errorf("expected green to be %#02x, but got %#02x", tc.g, g)
			}
			if b := c.B; b != tc.b {
				t.Errorf("expected blue to be %#02x, but got %#02x", tc.b, b)
			}
		})
	}
}

func TestColorHistogram(t *testing.T) {
	tt := []struct {
		desc     string
		pixels   []Color
		expected []Color
	}{
		{
			desc: "multiple pixels with clear top 3, added in order of precedence",
			pixels: []Color{
				// #1 most used
				{R: 0xFF, G: 0xAA, B: 0xDD},
				{R: 0xFF, G: 0xAA, B: 0xDD},
				{R: 0xFF, G: 0xAA, B: 0xDD},
				// #2 most used
				{R: 0x15, G: 0x10, B: 0x05},
				{R: 0x15, G: 0x10, B: 0x05},
				// #3 most used
				{R: 0x99, G: 0x42, B: 0xDA},
			},
			expected: []Color{
				{R: 0xFF, G: 0xAA, B: 0xDD},
				{R: 0x15, G: 0x10, B: 0x05},
				{R: 0x99, G: 0x42, B: 0xDA},
			},
		},
		{
			desc: "multiple pixels with clear top 3, interleaved on add",
			pixels: []Color{
				{R: 0xFF, G: 0xAA, B: 0xDD},
				{R: 0x15, G: 0x10, B: 0x05},
				{R: 0x15, G: 0x10, B: 0x05},
				{R: 0xFF, G: 0xAA, B: 0xDD},
				{R: 0x99, G: 0x42, B: 0xDA},
				{R: 0xFF, G: 0xAA, B: 0xDD},
			},
			expected: []Color{
				{R: 0xFF, G: 0xAA, B: 0xDD},
				{R: 0x15, G: 0x10, B: 0x05},
				{R: 0x99, G: 0x42, B: 0xDA},
			},
		},
		{
			desc:     "single pixel",
			pixels:   []Color{{R: 0xAA, G: 0xBA, B: 0xAB}},
			expected: []Color{{R: 0xAA, G: 0xBA, B: 0xAB}},
		},
	}
	for _, tc := range tt {
		t.Run(tc.desc, func(t *testing.T) {
			var ch ColorHistogram
			for _, p := range tc.pixels {
				ch.Add(p)
			}
			actual := ch.TopN(len(tc.expected))
			if len(actual) != len(tc.expected) {
				t.Fatalf("topN slices are different lengths: expected %d, got %d",
					len(actual), len(tc.expected))
			}
			for i := range tc.expected {
				t.Logf("expected[%d]: %v actual[%d]: %v", i, tc.expected[i], i, actual[i])
				if tc.expected[i] != actual[i] {
					t.Errorf("expected[%d] is %v, but actual[%d] is %v",
						i, tc.expected[i], i, actual[i])
				}
			}
		})
	}
}

// Test scenario where the TopN includes colors that have the same number of
// appearances. Because of the tie, the exact ordering of the TopN slice is not
// deterministic, because it is generated by iterating over a map, whose
// iteration order is not defined by the Go spec. Therefore, this test case
// needs to be handled differently from the others.
func TestColorHistogram_Tie(t *testing.T) {
	pixels := []Color{
		{R: 0xFA, G: 0xFA, B: 0xFA},
		{R: 0xFF, G: 0xFF, B: 0xFF},
		{R: 0xFE, G: 0xFE, B: 0xFE},
		{R: 0xF9, G: 0xF9, B: 0xF9},
		{R: 0xFF, G: 0xFF, B: 0xFF},
		{R: 0xFA, G: 0xFA, B: 0xFA},
		{R: 0xFE, G: 0xFE, B: 0xFE},
		{R: 0xFF, G: 0xFF, B: 0xFF},
		{R: 0xF1, G: 0xF1, B: 0xF1},
		{R: 0xF9, G: 0xF9, B: 0xF9},
		{R: 0xFE, G: 0xFE, B: 0xFE},
		{R: 0xF0, G: 0xF0, B: 0xF0},
	}
	expected := [][]Color{
		{
			// Most used
			{R: 0xFF, G: 0xFF, B: 0xFF},
			{R: 0xFE, G: 0xFE, B: 0xFE},
		},
		{
			// Second most used
			{R: 0xFA, G: 0xFA, B: 0xFA},
			{R: 0xF9, G: 0xF9, B: 0xF9},
		},
		{
			// Third most used
			{R: 0xF1, G: 0xF1, B: 0xF1},
			{R: 0xF0, G: 0xF0, B: 0xF0},
		},
	}
	var ch ColorHistogram
	for _, px := range pixels {
		ch.Add(px)
	}
	topN := ch.TopN(6)
	for i, want := range expected {
		// Get the subslice of tied entries from the topN slice.
		start, end := i*len(want), i*len(want)+len(want)
		got := topN[start:end]

		// Sort the actual and expected slices.
		less := func(a, b color.Color) bool {
			var aVal, bVal uint32
			{
				aR, aG, aB, aA := a.RGBA()
				bR, bG, bB, bA := b.RGBA()
				aVal = aR + aG + aB + aA
				bVal = bR + bG + bB + bA
			}
			return aVal < bVal
		}
		sort.Slice(want, func(a, b int) bool { return less(want[a], want[b]) })
		sort.Slice(got, func(a, b int) bool { return less(got[a], got[b]) })

		// Compare the sorted slices.
		for j := range want {
			if want[j] != got[j] {
				t.Errorf("section %d: want[%d] is %v, but got[%d] is %v",
					i, j, want[j], j, got[j])
			}
		}
	}
}

// Make sure the TopN is correct after adding additional pixels, after
// checking the TopN a first time.
func TestColorHistogram_LateAddition(t *testing.T) {
	pixels := []Color{
		{R: 0xFF, G: 0xFF, B: 0xFF},
		{R: 0xFF, G: 0xFF, B: 0xFF},
		{R: 0xAA, G: 0xAA, B: 0xAA},
	}
	expected := []Color{
		{R: 0xFF, G: 0xFF, B: 0xFF},
		{R: 0xAA, G: 0xAA, B: 0xAA},
	}
	var ch ColorHistogram
	for _, px := range pixels {
		ch.Add(px)
	}
	actual := ch.TopN(len(expected))
	for i := range actual {
		if expected[i] != actual[i] {
			t.Errorf("first check: expected[%d] is %v, but actual[%d] is %v",
				i, expected[i], i, actual[i])
		}
	}

	// Now add more pixels to change the ranking.
	ch.Add(Color{R: 0xAA, G: 0xAA, B: 0xAA})
	ch.Add(Color{R: 0xAA, G: 0xAA, B: 0xAA})

	actual = ch.TopN(len(expected))
	expected = []Color{
		{R: 0xAA, G: 0xAA, B: 0xAA},
		{R: 0xFF, G: 0xFF, B: 0xFF},
	}
	for i := range actual {
		if expected[i] != actual[i] {
			t.Errorf("after additions: expected[%d] is %v, but actual[%d] is %v",
				i, expected[i], i, actual[i])
		}
	}
}
